# 프로세스

# Process

## 정의

- 실행 중인 프로그램
- CPU를 할당하여 실행할 수 있게끔 디스패치가 가능한 대상
  - **디스패치(Dispatch)** : CPU 사용권을 주는 조작

## 개념

**프로세스 생성 시 RAM에 있는 내용**

![프로세스 구조](./img/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_1.png)

프로세스 구조

- code → 기계어로 코드 저장 **Read-Only**
- data → 전역 변수, static 변수 **Read-Write**
- heap → 동적할당
- stack : 없어질 것들을 저장함
  - 지역변수, 리턴 값, 매개변수, 돌아올 주소

### 프로세스 제어 블록 (PCB, Process Control Block)

- 특정 프로세스 정보 저장하는 데이터 블록이나 레코드로 작업 제어 블록 (TCB, Task Control Block)이라고도 부름
- 운영체제가 프로세스 제어 시 필요한 상태 정보 저장
- **프로세스가 생성**되면 메모리에 **PCB 생성**, 프로세스가 **실행 종료**되면 **같이 삭제**

![PCB 구조](./img/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_2.png)

PCB 구조

- **프로세스 식별자** : 각 프로세스의 고유 식별자
- **프로세스 상태** : 생성, 준비, 실행, 대기 등의 상태 표시
- **프로그램 카운터** : 다음 명령의 주소 표시
- **레지스터 저장 영역**
  - AC, 인덱스, 스택 포인터, 조건 코드 등의 정보 저장
  - 인터럽트(CPU의 정상적인 프로그램 실행을 방해했다는 것) 발생 시 PC와 함께 저장하여 원래대로 복귀할 수 있게 함
- **프로세서 스케줄링 정보** : 프로세서 우선순위, 스케줄링 큐의 포인터, 스케줄 매개변수
- **계정 정보** : 프로세서 사용 시간, 실제 사용시간, 계정 번호, 작업이나 프로세스 번호 등
- **입출력 상태 정보** : 할당된 입출력장치, 파일 리스트 등
- **메모리 관리 정보** : 메모리 상한, 하한 레지스터
- 기타 등등 …

### 상태

<aside>
💡 ⦁ **준비** : CPU를 받기 위해 기다리는 상태
⦁ **실행** : CPU를 받아서 할 일을 하는 상태
⦁ **대기** : 이벤트 발생으로 CPU를 놓고 이벤트의 완료를 기다리는 상태

</aside>

![프로세스 상태도](./img/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_3.png)

프로세스 상태도

| 상태변화             | 표기 방법               |
| -------------------- | ----------------------- |
| 1. 준비 → 실행       | dispatch(프로세스 이름) |
| 2. 실행 → 준비       | timeout(프로세스 이름)  |
| 3. 실행 → 대기(보류) | block(프로세스 이름)    |
| 4. 대기(보류) → 준비 | wakeup(프로세스 이름)   |

### 문맥 교환

- 자세한 설명
  [https://kosaf04pyh.tistory.com/195](https://kosaf04pyh.tistory.com/195)

<aside>
💡 현재 CPU를 사용 중인 프로세스의 **CPU 제어권이 다른 프로세스로 이양**되는 과정

</aside>

- 현재 CPU를 가진 프로세스의 PCB에 CPU의 레지스터 내용을 저장해놓고, 다음 CPU를 가질 프로세스의 PCB 내용을 불러와서 레지스터에 덮어쓴다.
- 실행 중인 프로세스에 인터럽트가 발생하면 생기는데, 인터럽트가 일어난 후 현재 실행 중인 프로세스를 재실행할 수 있어서 문맥 교환이 항상 일어나지는 않음

![문맥 교환 안 일어남](./img/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_4.png)

문맥 교환 안 일어남

![문맥 교환 일어남](./img/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_5.png)

문맥 교환 일어남

## 프로세스 생성과 종료

![트리 형태 (계층 구조)](./img/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_6.png)

트리 형태 (계층 구조)

- **과정**

<aside>
💡 **생성 fork()**
⦁ 식별자 부여 (PID), 주소 공간 할당, PCB 공간 할당
⦁ 부모의 프로세스의 메모리 공간, PCB 내용 복사 / **exec() 함수**로 원하는 값 덮어쓰기
⦁ 링크 걸기
⬇️
**종료 abort()** : 부모 프로세스가 자식 프로세스를 종료시키는 방법
⦁ **삭제 요청** : 부모는 자식 프로세스들이 모두 종료되어야 종료할 수 있다.
⬇️
**제거**
⦁ 메모리 공간 회수, 내용 삭제,
⦁ 프로그램 저장, PCB 회수, 자원 반환
⦁ 자식 프로세스는 부모 프로세스가 사라지면 자동 제거

</aside>

### **생성**

- 프로세스가 새로운 프로세스 생성 시
  - 복사된 프로세스 = 자식 프로세스
  - 복사 원본 프로세스 = 부모 프로세스
  - 복사할 때, 주소 공간과 PCB의 내용을 전부 복사
  - **exec() 함수**를 실행시켜 원하는 값으로 덮어쓰기

```c
#include <stdio.h>
#include <unistd.h>

int main() {
	int pid;
	int pid = fork();

	if(pid == 0) { // 자식 프로세스
		execlp("child : success!!", "0", NULL);
		exit(0);
	} else { // 부모 프로세스
		wait(NULL);
		printf("parent : success!!");
		exit(0);
	}
}
```

### **종료**

- 프로세스가 마지막 명령 실행 후 종료, 삭제 요청
- **abort() 함수**로 프로세스 종료
- 자식 프로세스가 종료되지 않으면 기다리고 자식 프로세스가 종료되는 상황은 다음과 같다.
  - 자식 프로세스가 할당된 자원을 초과하여 자원을 사용할 때
  - 자식 프로세스에 할당한 작업이 더는 없을 때
- 부모가 먼저 종료되거나 자식의 비정상적인 종료
  - **EX)** 좀비 프로세스, 고아 프로세스 등
  - 메모리를 차지함
  - 컴퓨터가 뭔가 느려짐
  - 해결 방법은 재부팅

### **제거**

- 프로세스 파괴
- 사용하던 자원을 돌려줌, PCB 회수
- 자식 프로세스는 부모 프로세스가 사라지면 자동 제거
- 프로그램은 디스크에 저장

### **중단과 재시작**

- 실행 중인 프로세스를 중단했다가 다시 실행(재시작)하면서 시스템 전체의 부하를 줄이는 것
- 다중 프로그래밍 환경에서의 중단을 입출력 요구 또는 자원 부족 상태
- 장시간 중단 시 할당된 자원 반환

![중단 상태가 추가된 프로세스 상태도](./img/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_7.png)

중단 상태가 추가된 프로세스 상태도

- **중단과 대기 차이**
  [https://c11.kr/1diop](https://c11.kr/1diop)
- **중단** : 할당된 자원을 기다리는 상태
- **대기** : 자원을 할당받으려고 기다리는 상태

## 프로세스 스케줄러

<aside>
💡 프로세스들이 CPU를 **할당받을 수 있도록 관리**해 주는 프로세스

</aside>

- PCB에 우선순위를 이용하여 준비 큐 프로세스 처리
- 준비 상태에 있는 프로세스는 입출력 중심 프로세스와 CPU 중심 프로세스로 구분
  - CPU 반환 시간으로 어떤 중심 프로세스 인지 구분함
  - **입출력 중심** : CPU를 짧게 자주 사용, 속도 느림(CPU를 사용했다 안 했다를 반복), 빠른 응답 요구에 높은 우선순위 부여
    ![Untitled](./img/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_8.png)
  - **CPU 중심** : CPU를 길게 사용, 사용 횟수를 줄여서 균형 유지
    ![Untitled](./img/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_9.png)
