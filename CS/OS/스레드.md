# 스레드 Thread

# 스레드란?

## 정의

<aside>
💡 프로세스 내에서 실행되는 프로그램 코드의 흐름을 의미한다.

</aside>

- **한 개의 프로세스** 내에서는 반드시 **하나 이상의 스레드**가 존재한다.
  - 1개 : 싱글 스레드 / n개 : 멀티 스레드
- 프로세스의 특성인 자원과 제어에서 제어만 분리한 실행 단위
- 같은 프로세스의 스레드들은 스택 Stack 공간만 독립적으로 가지고 동일한 주소 공간 공유
- 하나의 스레드에서 문제가 생길 경우, 프로세스 자체에 문제가 생길 수 있음

![프로세스 안에 존재하는 스레드](./img/%EC%8A%A4%EB%A0%88%EB%93%9C_1.png)

프로세스 안에 존재하는 스레드

**스레드가 생긴 이유**

- 프로세스 생성과 문맥 교환 작업이 많아지면 성능 저하 발생 → 가벼운 스레드 생성, 스위칭을 선호
- IPC보다 스레드 간 통신이 구현 및 관리 면에서 효율적이다.

### 차이점

|                       | process            | thread                         |
| --------------------- | ------------------ | ------------------------------ |
| 정의                  | 실행 중인 프로그램 | 프로세스 내의 코드 흐름        |
| 생성, 종료, 문맥 교환 | 많은 시간 소모     | 적은 시간 소모                 |
| 상호작용              | IPC - 오버헤드 ⬆️  | 공유 메모리 사용 - 오버헤드 ⬇️ |
| 독립성                | 각각 독립적        | 스택만 독립적, 나머지는 공유   |
| 안정성                | ⭕️                | ❌                             |

## 개념

![스레드_2.png](./img/%EC%8A%A4%EB%A0%88%EB%93%9C_2.png)

- 프로세스 내에서 스레드는 **별도의 Stack( + 스레드의 실행 환경 정보, 지역 데이터, 레지스터 등)**을 할당받고 **Code, Data, Heap** 영역은 같은 프로세스 내의 다른 스레드와 공유한다.

### 상태변화

- 프로세스와 같음(준비, 실행, 대기, 종료)
- 스레드의 상태변화는 다른 스레드의 상태에 영향을 끼칠 수 있음

### 스레드 제어 블록 (TCB, Tread Control Block)

- 실행 상태, 스케줄링 정보, 계정 정보, 다양한 포인터, 프로세스 제어 블록을 포함하는 포인터
- PCB 안에 TCB 리스트가 있음

![멀티 스레드를 표현한 그림](./img/%EC%8A%A4%EB%A0%88%EB%93%9C_3.png)

멀티 스레드를 표현한 그림

## 멀티 스레드

<aside>
💡 **싱글 스레드와 멀티 스레드** : 현대 운영체제는 대부분이 멀티 스레드이다.

</aside>

### 장점

**응답성**

- 싱글 스레드인 경우, 작업이 끝나기 전까지 사용자에게 응답하지 않는다. 반면 멀티 스레드인 경우 작업을 분리해서 수행하므로 실시간으로 사용자에게 응답할 수 있다.

**자원 공유**

- 프로세스는 오직 공유 메모리나 메시지 패싱을 이용해서 자원을 공유할 수 있지만, 스레드는 자신이 속한 프로세스 내의 스레드들과 메모리나 자원을 효율적으로 사용할 수 있다.

**경제성**

- 프로세스를 새로 생성하는 비용보다 스레드를 생성하는 게 훨씬 싸다. 그리고 Context switching의 오버헤드 또한 스레드가 더 경제적이다.

**확장성**

- 싱글 스레드인 경우 한 프로세스는 오직 한 CPU에서만 수행 가능하다. 반면 멀티 스레드인 경우 한 프로세스를 여러 CPU에서 수행할 수 있으므로 훨씬 효율적이다.

### 멀티 스레드의 병렬 수행

**CPU가 여러 개인 경우**

- CPU에서 여러 작업이 동시 수행 → **병렬적 수행**
  - **멀티 스레드** → 병렬성 높이기 좋음

![스레드_4.png](./img/%EC%8A%A4%EB%A0%88%EB%93%9C_4.png)

**CPU가 하나인 경우**

- 한 시점 하나의 작업만 수행 가능 → **동시성(병행성)**
  - 스위칭을 통해 병렬적 수행처럼 보일 수 있음

![스레드_5.png](./img/%EC%8A%A4%EB%A0%88%EB%93%9C_5.png)

## 구현

- 자세한 설명
  [https://helloinyong.tistory.com/293](https://helloinyong.tistory.com/293)
- 유저 스레드 - n : 1
- 커널 스레드 - 1 : 1
- 혼합형 스레드 - n : m

<aside>
👉🏻 **유저 스레드** : 안정성은 떨어지지만 성능 저하는 없다.
**커널 스레드** : 안정적, 유저 모드에서 커널 모드로 계속 바꿔줘야 해서 성능이 저하됨

</aside>

### **유저 스레드**

- 사용자 영역에서 연산
- 오버헤드 ⬇️
- 스레드 하나가 Block 되면 프로세스 자체가 Block됨
- 유저 영역에서 연산되니까 가볍고 스케줄링의 영향을 받지 않고 연산을 진행

### **커널 스레드**

- 커널 영역에서 연산
- 많아지면 성능 저하됨
- 스케줄링이 필요함
- 무겁고 연산이 오래 걸림
- 유저 모드에서 커널 모드로 계속 불러와서 실행해야 함

### N : 1 Many-to-One Model

![스레드_6.png](./img/%EC%8A%A4%EB%A0%88%EB%93%9C_6.png)

- 스레드 라이브러리로 스레드가 관리되어 효율적
- 한 번에 한 유저 스레드만 커널에 접근 → 병렬 수행 ❌
- 스레드 중 한 개가 Block 되면 프로세스도 Block됨

### 1 : 1 One-to-One Model

![스레드_7.png](./img/%EC%8A%A4%EB%A0%88%EB%93%9C_7.png)

- 동시성(병행성)을 높여주지만 커널 스레드가 늘어나면서 오버헤드가 커져 성능 저하가 발생됨

### N : M Many-to-Many Model

![스레드_8.png](./img/%EC%8A%A4%EB%A0%88%EB%93%9C_8.png)

- 어느 정도의 동시성(병행성)과 커널 스레드의 오버헤드 걱정이 없는 모델
